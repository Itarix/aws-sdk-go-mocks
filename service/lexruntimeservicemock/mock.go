// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/aws/aws-sdk-go/service/lexruntimeservice/lexruntimeserviceiface (interfaces: LexRuntimeServiceAPI)

// Package lexruntimeservicemock is a generated GoMock package.
package lexruntimeservicemock

import (
	context "context"
	request "github.com/aws/aws-sdk-go/aws/request"
	lexruntimeservice "github.com/aws/aws-sdk-go/service/lexruntimeservice"
	gomock "github.com/golang/mock/gomock"
	reflect "reflect"
)

// MockLexRuntimeServiceAPI is a mock of LexRuntimeServiceAPI interface
type MockLexRuntimeServiceAPI struct {
	ctrl     *gomock.Controller
	recorder *MockLexRuntimeServiceAPIMockRecorder
}

// MockLexRuntimeServiceAPIMockRecorder is the mock recorder for MockLexRuntimeServiceAPI
type MockLexRuntimeServiceAPIMockRecorder struct {
	mock *MockLexRuntimeServiceAPI
}

// NewMockLexRuntimeServiceAPI creates a new mock instance
func NewMockLexRuntimeServiceAPI(ctrl *gomock.Controller) *MockLexRuntimeServiceAPI {
	mock := &MockLexRuntimeServiceAPI{ctrl: ctrl}
	mock.recorder = &MockLexRuntimeServiceAPIMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockLexRuntimeServiceAPI) EXPECT() *MockLexRuntimeServiceAPIMockRecorder {
	return m.recorder
}

// PostContent mocks base method
func (m *MockLexRuntimeServiceAPI) PostContent(arg0 *lexruntimeservice.PostContentInput) (*lexruntimeservice.PostContentOutput, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "PostContent", arg0)
	ret0, _ := ret[0].(*lexruntimeservice.PostContentOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// PostContent indicates an expected call of PostContent
func (mr *MockLexRuntimeServiceAPIMockRecorder) PostContent(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PostContent", reflect.TypeOf((*MockLexRuntimeServiceAPI)(nil).PostContent), arg0)
}

// PostContentRequest mocks base method
func (m *MockLexRuntimeServiceAPI) PostContentRequest(arg0 *lexruntimeservice.PostContentInput) (*request.Request, *lexruntimeservice.PostContentOutput) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "PostContentRequest", arg0)
	ret0, _ := ret[0].(*request.Request)
	ret1, _ := ret[1].(*lexruntimeservice.PostContentOutput)
	return ret0, ret1
}

// PostContentRequest indicates an expected call of PostContentRequest
func (mr *MockLexRuntimeServiceAPIMockRecorder) PostContentRequest(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PostContentRequest", reflect.TypeOf((*MockLexRuntimeServiceAPI)(nil).PostContentRequest), arg0)
}

// PostContentWithContext mocks base method
func (m *MockLexRuntimeServiceAPI) PostContentWithContext(arg0 context.Context, arg1 *lexruntimeservice.PostContentInput, arg2 ...request.Option) (*lexruntimeservice.PostContentOutput, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "PostContentWithContext", varargs...)
	ret0, _ := ret[0].(*lexruntimeservice.PostContentOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// PostContentWithContext indicates an expected call of PostContentWithContext
func (mr *MockLexRuntimeServiceAPIMockRecorder) PostContentWithContext(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PostContentWithContext", reflect.TypeOf((*MockLexRuntimeServiceAPI)(nil).PostContentWithContext), varargs...)
}

// PostText mocks base method
func (m *MockLexRuntimeServiceAPI) PostText(arg0 *lexruntimeservice.PostTextInput) (*lexruntimeservice.PostTextOutput, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "PostText", arg0)
	ret0, _ := ret[0].(*lexruntimeservice.PostTextOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// PostText indicates an expected call of PostText
func (mr *MockLexRuntimeServiceAPIMockRecorder) PostText(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PostText", reflect.TypeOf((*MockLexRuntimeServiceAPI)(nil).PostText), arg0)
}

// PostTextRequest mocks base method
func (m *MockLexRuntimeServiceAPI) PostTextRequest(arg0 *lexruntimeservice.PostTextInput) (*request.Request, *lexruntimeservice.PostTextOutput) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "PostTextRequest", arg0)
	ret0, _ := ret[0].(*request.Request)
	ret1, _ := ret[1].(*lexruntimeservice.PostTextOutput)
	return ret0, ret1
}

// PostTextRequest indicates an expected call of PostTextRequest
func (mr *MockLexRuntimeServiceAPIMockRecorder) PostTextRequest(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PostTextRequest", reflect.TypeOf((*MockLexRuntimeServiceAPI)(nil).PostTextRequest), arg0)
}

// PostTextWithContext mocks base method
func (m *MockLexRuntimeServiceAPI) PostTextWithContext(arg0 context.Context, arg1 *lexruntimeservice.PostTextInput, arg2 ...request.Option) (*lexruntimeservice.PostTextOutput, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "PostTextWithContext", varargs...)
	ret0, _ := ret[0].(*lexruntimeservice.PostTextOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// PostTextWithContext indicates an expected call of PostTextWithContext
func (mr *MockLexRuntimeServiceAPIMockRecorder) PostTextWithContext(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PostTextWithContext", reflect.TypeOf((*MockLexRuntimeServiceAPI)(nil).PostTextWithContext), varargs...)
}
